import { state, animationSettings } from "../state/state.js";
import { buildKeyframesFromStep } from "../preview/previewEngine.js";


export function generateCodeFromTimeline(element) {
  element.textContent = "";
  const steps = state.steps;
  const lines = [];

  if (!steps || steps.length === 0) {
    element.textContent = "// No steps defined.";
    return;
  }

  // total timeline duration for the CSS animation
  const totalDuration = steps.reduce((sum, step) => sum + step.duration, 0);
  const firstStep = steps[0];

  // iterations → CSS iteration-count
  const iterationCount =
    animationSettings.iterations === "infinite"
      ? "infinite"
      : String(animationSettings.iterations || 1);

  // global timing-function for CSS (CSS can't easily do per-step easings)
  const globalEasing = firstStep.easing || "ease";

  // Helper: camelCase → kebab-case for CSS props (borderRadius → border-radius)
  function toKebabCase(name) {
    return name.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());
  }

  function frameToCssLines(frame, indent) {
    const out = [];
    for (const key in frame) {
      const cssProp = toKebabCase(key);
      out.push(`${indent}${cssProp}: ${frame[key]};`);
    }
    return out;
  }

  // CSS export
  lines.push(`<!-- Generated by Motion Builder JS -->`);
  lines.push(`<!-- 1) Attach .mbjs-animation to your element (or let the JS below do it). -->`);
  lines.push(`<!-- 1) Copy this entire section and place inside your <body> tag. -->`);
  lines.push(`<!-- 2) Replace "#your-element" in the script with your real selector. -->`);
  lines.push(``);
  lines.push(`<style>`);
  lines.push(`.mbjs-animation {`);
  lines.push(`  animation-name: mbjs-animation;`);
  lines.push(`  animation-duration: ${totalDuration}ms;`);
  lines.push(`  animation-timing-function: ${globalEasing};`);
  lines.push(`  animation-iteration-count: ${iterationCount};`);
  lines.push(`  animation-fill-mode: forwards;`);
  lines.push(`}`);
  lines.push(``);
  lines.push(`@keyframes mbjs-animation {`);

  let accumulated = 0;

  steps.forEach((step, index) => {
    const [fromFrame, toFrame] = buildKeyframesFromStep(step);

    const startPercent = Math.round((accumulated / totalDuration) * 100);
    const endPercent = Math.round(
      ((accumulated + step.duration) / totalDuration) * 100
    );

    // Start of this step
    lines.push(``);
    lines.push(`  /* Step ${index + 1} */`);
    lines.push(``);
    lines.push(`  ${startPercent}% {`);
    frameToCssLines(fromFrame, "    ").forEach((l) => lines.push(l));
    lines.push(`  }`);

    // End of this step
    lines.push(`  ${endPercent}% {`);
    frameToCssLines(toFrame, "    ").forEach((l) => lines.push(l));
    lines.push(`  }`);

    accumulated += step.duration;

    // ensure we end exactly at 100% for the last step
    if (index === steps.length - 1 && endPercent !== 100) {
      lines.push(`  100% {`);
      frameToCssLines(toFrame, "    ").forEach((l) => lines.push(l));
      lines.push(`  }`);
    }
  });

  lines.push(`}`);
  lines.push(`</style>`);
  lines.push(``);

  // JS export
  lines.push(`<script>`);
  lines.push(`const element = document.querySelector("#your-element");`);
  lines.push(``);
  lines.push(`function startMotionBuilderAnimation() {`);
  lines.push(`  if (!element) return;`);
  lines.push(`  // reset animation so it can be replayed`);
  lines.push(`  element.classList.remove("mbjs-animation");`);
  lines.push(`  void element.offsetWidth; // force reflow to restart animation`);
  lines.push(`  element.classList.add("mbjs-animation");`);
  lines.push(`}`);
  lines.push(``);

  // trigger wiring based on animationSettings.trigger
  lines.push(`// Trigger wiring (from Motion Builder settings)`);

  const trigger = animationSettings.trigger || "manual";

  if (trigger === "hover") {
    lines.push(`if (element) {`);
    lines.push(`  element.addEventListener("mouseenter", startMotionBuilderAnimation);`);
    lines.push(`  element.addEventListener("mouseleave", () => {`);
    lines.push(`    element.classList.remove("mbjs-animation");`);
    lines.push(`  });`);
    lines.push(`}`);
  } else if (trigger === "click") {
    lines.push(`if (element) {`);
    lines.push(`  element.addEventListener("click", startMotionBuilderAnimation);`);
    lines.push(`}`);
  } else if (trigger === "load") {
    lines.push(`window.addEventListener("load", () => {`);
    lines.push(`  startMotionBuilderAnimation();`);
    lines.push(`});`);
  } else {
    // manual: user calls the function themselves
    lines.push(`// If manual trigger mode:`);
    lines.push(`// Call startMotionBuilderAnimation() whenever you want to run the animation.`);
  }

  lines.push(`</script>`);

  element.textContent = lines.join("\n");
}